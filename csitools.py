from matlab import db, dbinv

import numpy as np
import os

def getCSI(trace, metric="amplitude"):
    no_frames = len(trace)
    no_subcarriers = trace[0]["csi"].shape[0]

    csi = np.zeros((no_subcarriers, no_frames))

    for x in range(no_frames):
        scaled_entry = trace[x]["csi"]
        for y in range(no_subcarriers):
            if metric == "amplitude":
                csi[y][x] = db(abs(scaled_entry[y]))
                # csi[y][x] = abs(scaled_entry[y])
            elif metric == "phasediff":
                if scaled_entry.shape[1] >= 2:
                    #Not 100% sure this generates correct Phase Difference.
                    csi[y][x] = np.angle(scaled_entry[y][1][0])-np.angle(scaled_entry[y][0][0])
                else:
                    #In cases where only one antenna is available, reuse the previous value.
                    csi[y][x] = csi[y][x-1]

    return (csi, no_frames, no_subcarriers)

def getTimestamps(trace, relative=True):
    key = "scaled_timestamp" if relative else "timestamp"
    return list([x[key] for x in trace])

def get_total_rss(rssi_a, rssi_b, rssi_c, agc):
    # Calculates the Received Signal Strength (RSS) in dBm from
    # Careful here: rssis could be zero
        rssi_mag = 0
        if rssi_a != 0:
            rssi_mag = rssi_mag + dbinv(rssi_a)
        if rssi_b != 0:
            rssi_mag = rssi_mag + dbinv(rssi_b)
        if rssi_c != 0:
            rssi_mag = rssi_mag + dbinv(rssi_c)

        #Interpreting RSS magnitude as power for RSS/dBm conversion.
        #This is consistent with Linux 802.11n CSI Tool's MATLAB implementation.
        return db(rssi_mag, "pow") - 44 - agc

def scale_csi_entry(frame):
    """
        This function performs scaling on the retrieved CSI data to account for automatic gain control and other factors.
        Code within this section is largely based on the Linux 802.11n CSI Tool's MATLAB implementation (get_scaled_csi.m).

        Args:
            frame {dict} -- CSI frame object for which CSI is to be scaled.
    """

    csi = frame["csi"]

    n_rx = frame["n_rx"]
    n_tx = frame["n_tx"]

    rssi_a = frame["rssi_a"]
    rssi_b = frame["rssi_b"]
    rssi_c = frame["rssi_c"]

    agc = frame["agc"]
    noise = frame["noise"]

    #Calculate the scale factor between normalized CSI and RSSI (mW).
    csi_sq = np.multiply(csi, np.conj(csi))
    csi_pwr = np.sum(csi_sq)
    csi_pwr = np.real(csi_pwr)

    rssi_pwr_db = get_total_rss(rssi_a, rssi_b, rssi_c, agc)
    rssi_pwr = dbinv(rssi_pwr_db)
    #Scale CSI -> Signal power : rssi_pwr / (mean of csi_pwr)
    scale = rssi_pwr / (csi_pwr / 30)

    #Thermal noise may be undefined if the trace was captured in monitor mode.
    #If so, set it to 92.
    noise_db = noise
    if (noise == -127):
        noise_db = -92

    noise_db = np.float(noise_db)
    thermal_noise_pwr = dbinv(noise_db)

    #Quantization error: the coefficients in the matrices are 8-bit signed numbers,
    #max 127/-128 to min 0/1. Given that Intel only uses a 6-bit ADC, I expect every
    #entry to be off by about +/- 1 (total across real and complex parts) per entry.

    #The total power is then 1^2 = 1 per entry, and there are Nrx*Ntx entries per
    #carrier. We only want one carrier's worth of error, since we only computed one
    #carrier's worth of signal above.
    quant_error_pwr = scale * (n_rx * n_tx)

    #Noise and error power.
    total_noise_pwr = thermal_noise_pwr + quant_error_pwr

    # ret now has units of sqrt(SNR) just like H in textbooks.
    ret = csi * np.sqrt(scale / total_noise_pwr)
    if n_tx == 2:
        ret = ret * np.sqrt(2)
    elif n_tx == 3:
        #Note: this should be sqrt(3)~ 4.77dB. But 4.5dB is how
        #Intel and other makers approximate a factor of 3.
        #You may need to change this if your card does the right thing.
        ret = ret * np.sqrt(dbinv(4.5))

    return ret

def scale_timestamps(csi_trace):
    """
        This function adds an additional "timestamp" to each trace by assigning differential timestamps based on "timestamp_low".
        timestamp_low represents the current state of the low 32 bits of the IWL5300's clock.
        Since it wraps around every 72 minutes, the absolute timestamp values are rarely useful without context.
        Relative timestamps are typically easier to graph and represent most use cases more effectively.

        Args:
            csi_trace List[dict] -- A list of CSI frame structs as generated by read_bf_file.
    """

    time = [x["timestamp_low"] for x in csi_trace]

    timediff = (np.diff(time))*10e-7
    time_stamp = np.cumsum(timediff)

    csi_trace[0]["timestamp"] = 0
    for x in csi_trace[1:]:
        x["timestamp"] = time_stamp[csi_trace.index(x)-1]

def print_length_error(self, length, data_length, i):
    """
        Prints an error to highlight a difference between the frame's stated data size and the actual size.
        This usually stems from file termination.

        Args:
            length {int} -- Stated length of the CSI data payload from the frame header.
            data_length {int} -- Actual length as derived from the payload.
    """

    print("Invalid length for CSI frame {} in {}.".format(i, os.path.basename(filename)))
    print("\tExpected {} bytes but got {} bytes.".format(length, data_length))
    if data_length < length:
        print("\tLast packet was likely cut off by an improper termination.")
        print("\tWhen killing log_to_file, use SIGTERM and ensure writes have been flushed, and files closed.")

    return False