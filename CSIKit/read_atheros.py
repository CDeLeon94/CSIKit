import collections
import os
import struct
import sys
from math import floor

# from csitools import scale_timestamps, scale_csi_entry
# from errors import print_length_error

import numpy as np
import scipy.io

SIZE_STRUCT = struct.Struct(">H").unpack

HEADER_STRUCT = struct.Struct(">QHHBBBBBBBBBBBH").unpack
HEADER_FORMAT = collections.namedtuple("packet_header", ["timestamp", "csi_length", "tx_channel", "err_info", "noise_floor", "rate", "bandwidth", "num_tones", "nr", "nc", "rssi", "rssi_1", "rssi_2", "rssi_3", "payload_length"])

TONE_40M = 114
BITS_PER_BYTE = 8
BITS_PER_SYMBOL = 10
BITS_PER_COMPLEX_SYMBOL = 2 * BITS_PER_SYMBOL

class ATHBeamformReader:

    def __init__(self, filename="", scaled=False):
        self.filename = filename
        self.scaled = scaled

        if filename == "":
            print("Realtime ATHBeamformReader initialised.")
        elif os.path.exists(filename):
            with open(filename, "rb") as file:
                self.csi_trace = self.read_bf_file(file)
            # self.csi_trace = scale_timestamps(self.csi_trace)
        else:
            print("Could not find file: {}".format(filename))

    def signbit_convert(self, data, maxbit):
        if (data & (1 << (maxbit - 1))):
            data -= (1 << maxbit)

        return data

    def get_next_bits(self, buf, current_data, idx, bits_left):
        h_data = buf[idx]
        idx += 1
        h_data += (buf[idx] << BITS_PER_BYTE)
        idx += 1
        current_data += h_data << bits_left
        bits_left += 16

        return (current_data, idx, bits_left)

    def read_bfee(self, csi_buf, nr, nc, num_tones):

        csi = np.empty((num_tones, nc, nr), dtype=np.complex)

        bitmask = (1 << BITS_PER_SYMBOL) - 1
        idx = 0
        bits_left = 16
        
        h_data = csi_buf[idx]
        idx += 1
        h_data += (csi_buf[idx] << 8)
        idx += 1
        current_data = h_data & ((1 << 16) - 1)
        
        for k in range(num_tones):
            for nc_idx in range(nc):
                for nr_idx in range(nr):
                    if ((bits_left - BITS_PER_SYMBOL) < 0):
                        current_data, idx, bits_left = self.get_next_bits(csi_buf, current_data, idx, bits_left)
                    
                    imag = current_data & bitmask
                    imag = self.signbit_convert(imag, BITS_PER_SYMBOL)
                    imag += 1

                    bits_left -= BITS_PER_SYMBOL
                    current_data = current_data >> BITS_PER_SYMBOL

                    if ((bits_left - BITS_PER_SYMBOL) < 0):
                        current_data, idx, bits_left = self.get_next_bits(csi_buf, current_data, idx, bits_left)

                    real = current_data & bitmask
                    real = self.signbit_convert(real, BITS_PER_SYMBOL)
                    real += 1

                    bits_left -= BITS_PER_SYMBOL
                    current_data = current_data >> BITS_PER_SYMBOL

                    csi[k, nc_idx, nr_idx] = np.complex(real, imag)

        # if self.scaled:
        #     scaled_csi = scale_csi_entry(csi_block)
        #     csi_block["scaled_csi"] = scaled_csi

        return csi

    def read_bf_file(self, file):
        """
            This function parses .dat files generated by log_to_file.

            Parameters:
                file (filereader): File reader object returned from open().

            Returns:
                total_csi (list): All valid CSI blocks contained within the given file.
        """

        data = file.read()
        length = len(data)

        total_csi = []
        cur = 0
        expected_count = 0

        while cur < (length - 4):
            field_length = SIZE_STRUCT(data[cur:cur+2])[0]
            cur += 2
            
            if (cur + field_length) > length:
                break

            header_block = HEADER_FORMAT._make(HEADER_STRUCT(data[cur:cur+25]))
            cur += 25

            if header_block.csi_length > 0:
                data_block = data[cur:cur+header_block.csi_length]

                csi_data = self.read_bfee(data_block, header_block.nr, header_block.nc, header_block.num_tones)
                if csi_data is not None:
                    total_csi.append({
                        "header": header_block,
                        "csi": csi_data
                    })

                expected_count += 1
                cur += header_block.csi_length

            if header_block.payload_length > 0:
                cur += header_block.payload_length

            cur += 21

            if (cur + 420 > length):
                break

        return total_csi

if __name__ == "__main__":

    if len(sys.argv) > 2:
        path = sys.argv[2]
    else:
        path = "./data/atheros/Ant_1.dat"

    reader = ATHBeamformReader(path)
    print("Have CSI for {} packets.".format(len(reader.csi_trace)))